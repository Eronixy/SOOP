from enum import Enum

# Token definitions
TOKEN_EOF = 'EOF'
TOKEN_ERROR = 'ERROR'
TOKEN_UNKNOWN = 'UNKNOWN'
TOKEN_INDENT = 'INDENT'
TOKEN_COMMENT = 'COMMENT'
TOKEN_INTEGER_LITERAL = 'INTEGER_LITERAL'
TOKEN_FLOAT_LITERAL = 'FLOAT_LITERAL'
TOKEN_STRING_LITERAL = 'STRING_LITERAL'
TOKEN_BOOL_TRUE = 'BOOL_TRUE'
TOKEN_BOOL_FALSE = 'BOOL_FALSE'
TOKEN_NULL = 'NULL'
TOKEN_IDENTIFIER = 'IDENTIFIER'
TOKEN_DEDENT = 'DEDENT'

# Language keywords
TOKEN_PRINT = 'PRINT'
TOKEN_INPUT = 'INPUT'
TOKEN_IN = 'IN'
TOKEN_DEF = 'DEF'
TOKEN_CLASS = 'CLASS'
TOKEN_TEMPLATE = 'TEMPLATE'
TOKEN_NEW = 'NEW'
TOKEN_SETUP = 'SETUP'
TOKEN_ACTION = 'ACTION'
TOKEN_STATIC = 'STATIC'
TOKEN_INHERITS = 'INHERITS'
TOKEN_PARENT = 'PARENT'
TOKEN_OVERRIDE = 'OVERRIDE'
TOKEN_THIS = 'THIS'

# Control flow tokens
TOKEN_IF = 'IF'
TOKEN_ELSE = 'ELSE'
TOKEN_FOR = 'FOR'
TOKEN_WHILE = 'WHILE'
TOKEN_BREAK = 'BREAK'
TOKEN_CONTINUE = 'CONTINUE'
TOKEN_RETURN = 'RETURN'
TOKEN_SWITCH = 'SWITCH'
TOKEN_RANGE = 'RANGE'

# Exception handling tokens
TOKEN_TRY = 'TRY'
TOKEN_CATCH = 'CATCH'
TOKEN_FINALLY = 'FINALLY'
TOKEN_RAISE = 'RAISE'


# Module related tokens
TOKEN_IMPORT = 'IMPORT'
TOKEN_DEFINE = 'DEFINE'

# Object tokens
TOKEN_CREATE = 'CREATE'
TOKEN_DELETE = 'DELETE'

# Access modifiers
TOKEN_PUBLIC = 'PUBLIC'
TOKEN_RESTRICTED = 'RESTRICTED'
TOKEN_PRIVATE = 'PRIVATE'

# Concurrency tokens
TOKEN_ASYNC = 'ASYNC'
TOKEN_AWAIT = 'AWAIT'
TOKEN_CONCURRENT = 'CONCURRENT'
TOKEN_IMMUTABLE = 'IMMUTABLE'
TOKEN_DELEGATE = 'DELEGATE'
TOKEN_YIELD = 'YIELD'
TOKEN_THREAD = 'THREAD'

# Data type tokens
TOKEN_TYPE_INT = 'TYPE_INT'
TOKEN_TYPE_DOUBLE = 'TYPE_DOUBLE'
TOKEN_TYPE_FLOAT = 'TYPE_FLOAT'
TOKEN_TYPE_BOOL = 'TYPE_BOOL'
TOKEN_TYPE_LIST = 'TYPE_LIST'
TOKEN_TYPE_DICT = 'TYPE_DICT'
TOKEN_TYPE_STRING = 'TYPE_STRING'

# Operator tokens
TOKEN_INCREMENT = 'INCREMENT'
TOKEN_DECREMENT = 'DECREMENT'
TOKEN_ASSIGN = 'ASSIGN'
TOKEN_PLUS_ASSIGN = 'PLUS_ASSIGN'
TOKEN_MINUS_ASSIGN = 'MINUS_ASSIGN'
TOKEN_MULTIPLY_ASSIGN = 'MULTIPLY_ASSIGN'
TOKEN_DIVIDE_ASSIGN = 'DIVIDE_ASSIGN'
TOKEN_MODULO_ASSIGN = 'MODULO_ASSIGN'
TOKEN_FLOOR_DIVIDE_ASSIGN = 'FLOOR_DIVIDE_ASSIGN'
TOKEN_GREATER_EQUAL = 'GREATER_EQUAL'
TOKEN_LESS_EQUAL = 'LESS_EQUAL'
TOKEN_EQUAL = 'EQUAL'
TOKEN_NOT_EQUAL = 'NOT_EQUAL'
TOKEN_GREATER = 'GREATER'
TOKEN_LESS = 'LESS'
TOKEN_LOGICAL_OR = 'LOGICAL_OR'
TOKEN_LOGICAL_AND = 'LOGICAL_AND'
TOKEN_LOGICAL_NOT = 'LOGICAL_NOT'
TOKEN_PLUS = 'PLUS'
TOKEN_MINUS = 'MINUS'
TOKEN_MULTIPLY = 'MULTIPLY'
TOKEN_DIVIDE = 'DIVIDE'
TOKEN_MODULO = 'MODULO'
TOKEN_FLOOR_DIVIDE = 'FLOOR_DIVIDE'
TOKEN_CARET = 'CARET'

# Delimiter tokens
TOKEN_LPAREN = 'LPAREN'
TOKEN_RPAREN = 'RPAREN'
TOKEN_LBRACE = 'LBRACE'
TOKEN_RBRACE = 'RBRACE'
TOKEN_COLON = 'COLON'
TOKEN_SEMICOLON = 'SEMICOLON'
TOKEN_COMMA = 'COMMA'
TOKEN_DOT = 'DOT'
TOKEN_QUOTE = 'QUOTE'
TOKEN_NEWLINE = 'NEWLINE'

# Mappings
KEYWORDS = {
    "print": TOKEN_PRINT,
    "input": TOKEN_INPUT,
    "in": TOKEN_IN,
    "def": TOKEN_DEF,
    "class": TOKEN_CLASS,
    "template": TOKEN_TEMPLATE,
    "new": TOKEN_NEW,
    "setup": TOKEN_SETUP,
    "action": TOKEN_ACTION,
    "static": TOKEN_STATIC,
    "inherits": TOKEN_INHERITS,
    "parent": TOKEN_PARENT,
    "override": TOKEN_OVERRIDE,
    "this": TOKEN_THIS,
    "if": TOKEN_IF,
    "else": TOKEN_ELSE,
    "for": TOKEN_FOR,
    "while": TOKEN_WHILE,
    "range": TOKEN_RANGE,
    "break": TOKEN_BREAK,
    "continue": TOKEN_CONTINUE,
    "return": TOKEN_RETURN,
    "switch": TOKEN_SWITCH,
    "try": TOKEN_TRY,
    "catch": TOKEN_CATCH,
    "finally": TOKEN_FINALLY,
    "raise": TOKEN_RAISE,
    "import": TOKEN_IMPORT,
    "define": TOKEN_DEFINE,
    "create": TOKEN_CREATE,
    "delete": TOKEN_DELETE,
    "public": TOKEN_PUBLIC,
    "restricted": TOKEN_RESTRICTED,
    "private": TOKEN_PRIVATE,
    "async": TOKEN_ASYNC,
    "await": TOKEN_AWAIT,
    "concurrent": TOKEN_CONCURRENT,
    "immutable": TOKEN_IMMUTABLE,
    "delegate": TOKEN_DELEGATE,
    "yield": TOKEN_YIELD,
    "thread": TOKEN_THREAD
}

SYMBOLS = sorted([
    ("++", TOKEN_INCREMENT),
    ("--", TOKEN_DECREMENT),
    ("+=", TOKEN_PLUS_ASSIGN),
    ("-=", TOKEN_MINUS_ASSIGN),
    ("*=", TOKEN_MULTIPLY_ASSIGN),
    ("/=", TOKEN_DIVIDE_ASSIGN),
    ("%=", TOKEN_MODULO_ASSIGN),
    ("//=", TOKEN_FLOOR_DIVIDE_ASSIGN),
    ("=", TOKEN_ASSIGN),
    (">=", TOKEN_GREATER_EQUAL),
    ("<=", TOKEN_LESS_EQUAL),
    ("==", TOKEN_EQUAL),
    ("!=", TOKEN_NOT_EQUAL),
    (">", TOKEN_GREATER),
    ("<", TOKEN_LESS),
    ("||", TOKEN_LOGICAL_OR),
    ("&&", TOKEN_LOGICAL_AND),
    ("!", TOKEN_LOGICAL_NOT),
    ("//", TOKEN_FLOOR_DIVIDE),
    ("+", TOKEN_PLUS),
    ("-", TOKEN_MINUS),
    ("*", TOKEN_MULTIPLY),
    ("/", TOKEN_DIVIDE),
    ("%", TOKEN_MODULO),
    ("^", TOKEN_CARET),
    ("(", TOKEN_LPAREN),
    (")", TOKEN_RPAREN),
    ("{", TOKEN_LBRACE),
    ("}", TOKEN_RBRACE),
    (":", TOKEN_COLON),
    (";", TOKEN_SEMICOLON),
    (",", TOKEN_COMMA),
    (".", TOKEN_DOT),
    ("\"", TOKEN_QUOTE),
    ("\n", TOKEN_NEWLINE)
], key=lambda x: len(x[0]), reverse=True)

DATA_TYPES = {
    "int": TOKEN_TYPE_INT,
    "double": TOKEN_TYPE_DOUBLE,
    "float": TOKEN_TYPE_FLOAT,
    "bool": TOKEN_TYPE_BOOL,
    "list": TOKEN_TYPE_LIST,
    "dict": TOKEN_TYPE_DICT,
    "string": TOKEN_TYPE_STRING
}

BOOL_VALUES = {
    "true": TOKEN_BOOL_TRUE,
    "false": TOKEN_BOOL_FALSE,
    "null": TOKEN_NULL
}